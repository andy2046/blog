# [React] React-Redux æºç è§£è¯»

![redux logo](https://user-images.githubusercontent.com/2193706/36361283-c3e111bc-1565-11e8-8ca4-fb10beb1dc55.png)

---

![react-redux work flow](https://user-images.githubusercontent.com/2193706/36361298-da48434e-1565-11e8-8848-6232f6ada34d.png)

# ä»‹ç»
ä¸Šé¢ğŸ‘†æˆ‘ä»¬ç ”ç©¶äº†[Redux](https://github.com/andy2046/blog/issues/5)ï¼Œç°åœ¨çš„ç–‘é—®æ˜¯å¦‚ä½•è®©Reactå’ŒReduxè¿™å¯¹å¥½åŸºå‹ğŸ‘¬åœ¨ä¸€èµ·ï¼Œç­”æ¡ˆå°±æ˜¯`react-redux` (react-redux v5.0.7)

`react-redux`é€šè¿‡`Provider`ç»„ä»¶ï¼ˆcomponentï¼‰ä»¥contextæ–¹å¼å‘åº”ç”¨æ³¨å…¥storeï¼Œè¿™æ ·å•ä¸ªç»„ä»¶ï¼ˆcomponentï¼‰å¯ä»¥ä½¿ç”¨`connect`é«˜é˜¶æ–¹æ³•ï¼Œè·å–å¹¶ç›‘å¬store stateï¼Œæ ¹æ®store state treeå’Œç»„ä»¶è‡ªèº«propsè®¡ç®—å¾—åˆ°æ–°çš„propså¹¶æ³¨å…¥è¯¥ç»„ä»¶ï¼Œå¹¶ä¸”å¯ä»¥é€šè¿‡ç›‘å¬store stateï¼Œæ¯”è¾ƒè®¡ç®—å‡ºçš„æ–°çš„propsæ¥åˆ¤æ–­æ˜¯å¦éœ€è¦æ›´æ–°ç»„ä»¶

# å®ä¾‹ä»£ç 

ä¸¾ä¸ªæ —å­ğŸŒ°çœ‹çœ‹åº”ç”¨ä»£ç ä¸­å¦‚ä½•ä½¿ç”¨`react-redux`
```js
import ReactDOM        from 'react-dom'
import { Provider }    from 'react-redux'
import { createStore } from 'redux'
import App             from './components/App'
import rootReducer     from './reducers'

const store = createStore(rootReducer)

ReactDOM.render(
  <Provider store={store}>
    <App />
  </Provider>, document.getElementById('root')
)
```

```js
import React, { Component } from 'react'
import { connect }          from 'react-redux'
import Todo                 from 'components/Todo'

class TodoContainer extends Component {
  constructor(props) {
    super(props)
    this.state = { todos: null, filter: null }
  }
  handleUpdate = (todo) => {
    this.props.update(todo)
  }
  componentDidMount() {
    const { todos, filter, fetchTodos } = this.props
    if (todos.length === 0) {
      fetchTodos(filter)
    }
  render () {
    const { todos, filter } = this.props

    return (
      <Todo
        todos={todos}
        filter={filter}
        handleUpdate={this.handleUpdate}
      />
    )
  }
}

const mapStateToProps = state => {
  return {
    todos : state.todos,
    filter: state.filter
  }
}

const mapDispatchToProps = dispatch => {
  return {
    update: (todo) => dispatch({
      type: 'UPDATE_TODO',
      payload: todo
    }),
    fetchTodos: (filter) => dispatch({
      type: 'FETCH_TODOS',
      payload: filter
    })
  }
}

export default connect(
  mapStateToProps,
  mapDispatchToProps
)(TodoContainer)
```

# æ•´ä½“ç»“æ„
![react-redux source code structure](https://user-images.githubusercontent.com/2193706/36362699-09291dee-1572-11e8-8087-549860b20067.png)

## Provider.js
è¿™é‡Œé»˜è®¤è¿”å›`createProvider()`, `createProvider`å‡½æ•°æ˜¯ç”¨æ¥å®šåˆ¶Providerï¼Œ`Provider`ç»„ä»¶ç”¨æ¥ç»™å­ç»„ä»¶æä¾›store stateæ•°æ®ï¼Œstoreå­˜æ”¾åœ¨contextä¸­

é€šè¿‡Context APIæŠŠä½œä¸ºpropsä¼ å…¥çš„storeæ”¾åœ¨`this[storeKey]`ï¼Œç„¶ååœ¨`getChildContext`ä¸­æŠŠè¿™ä¸ªstoreè¿”å›ç»™å­ç»„ä»¶

ä¸ºäº†è®©å­ç»„ä»¶èƒ½å¤Ÿè®¿é—®åˆ°contextï¼Œå¿…é¡»åŒæ—¶å®šä¹‰`getChildContext`å‡½æ•°å’Œ`static childContextTypes = {}`

Providerçš„`render`å‡½æ•°è¿”å›`Children.only(this.props.children)`ï¼ŒChildren.onlyè¿”å›ä»…æœ‰çš„ä¸€ä¸ªå­ç»„ä»¶ï¼Œå¦åˆ™æŠ¥é”™ï¼Œæ‰€ä»¥Provideråªæ”¯æŒå•ä¸ªå­ç»„ä»¶
```js
import { Component, Children } from 'react'
import PropTypes from 'prop-types'
import { storeShape, subscriptionShape } from '../utils/PropTypes'

export function createProvider(storeKey = 'store', subKey) {
    const subscriptionKey = subKey || `${storeKey}Subscription`

    class Provider extends Component {
        getChildContext() {
          return { [storeKey]: this[storeKey], [subscriptionKey]: null }
        }

        constructor(props, context) {
          super(props, context)
          this[storeKey] = props.store;
        }

        render() {
          return Children.only(this.props.children)
        }
    }

    Provider.propTypes = {
        store: storeShape.isRequired,
        children: PropTypes.element.isRequired,
    }
    Provider.childContextTypes = {
        [storeKey]: storeShape.isRequired,
        [subscriptionKey]: subscriptionShape,
    }

    return Provider
}

export default createProvider()
```

## connect.js
è¿™é‡Œé»˜è®¤è¿”å›`createConnect()`, `createConnect`æ˜¯é«˜é˜¶å‡½æ•°ï¼Œç”¨æ¥è¿”å›`connect`å‡½æ•°ï¼Œæ¥å—ä¸€ä¸ªå¯¹è±¡å‚æ•°ï¼Œå‚æ•°keyåŒ…æ‹¬`connectHOC` `mapStateToPropsFactories` `mapDispatchToPropsFactories` `mergePropsFactories` `selectorFactory`ï¼Œæ¯ä¸€ä¸ªéƒ½æœ‰default value

#### connectHOC
ç”¨æ¥ç”Ÿæˆè¿æ¥åˆ°storeçš„é«˜é˜¶ç»„ä»¶(HOC)ï¼Œé»˜è®¤æ˜¯`connectAdvanced`

#### selectorFactory
ç”¨æ¥ç”Ÿæˆ`selector`ï¼Œå®ƒä¹Ÿä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°è¢«ä¼ å…¥`connectAdvanced`ï¼Œä¼ å…¥connectAdvancedçš„selectorFactoryå‡½æ•°ä¸»è¦ç”¨æ¥åˆå§‹åŒ–selectorå‡½æ•°ï¼Œselectorå‡½æ•°è¢«è°ƒç”¨æ—¶è®¡ç®—æ–°çš„propsï¼Œä»¥çº¯å¯¹è±¡(plain object)è¿”å›, è¿™ä¸ªå¯¹è±¡ä½œä¸ºpropsä¼ é€’ç»™è¿æ¥ç»„ä»¶(Connect component)

selectorFactoryçš„å‡½æ•°ç­¾åï¼š
`(dispatch, options) => (nextState, nextOwnProps) => nextFinalProps`

connectå°†å®ƒçš„å‚æ•°ä½œä¸º`options`ä¼ é€’ç»™connectAdvancedï¼Œæ¯æ¬¡è¿æ¥ç»„ä»¶(Connect component)è¢«å®ä¾‹åŒ–æˆ–çƒ­åŠ è½½æ—¶ï¼Œoptionsåˆè¢«ä¼ é€’ç»™selectorFactoryï¼ŒselectorFactoryä»å®ƒçš„mapStateToProps mapDispatchToProps mergeProps optionsä¸­è¿”å›ä¸€ä¸ªfinal props selectorï¼ŒConnect componentå®ä¾‹æ”¶åˆ°æ–°çš„propsæˆ–store stateæ—¶ï¼Œè¿™ä¸ªfinal props selectoræ¯æ¬¡éƒ½è¢«è°ƒç”¨ï¼Œ è¿”å›æ–°çš„final props

```js
// selectorFactory.js
å¦‚æœoptions.pureä¸ºtrueï¼Œåˆ™selectorFactoryè¿”å›çš„selectorå°†ç¼“å­˜å…¶ç»“æœï¼Œ
å¦‚æœfinal propsæ²¡æœ‰æ”¹å˜ï¼Œåˆ™å…è®¸connectAdvancedçš„shouldComponentUpdateè¿”å›falseï¼Œ
å¦‚æœoptions.pureä¸ºfalseï¼Œselectorå°†å§‹ç»ˆè¿”å›ä¸€ä¸ªæ–°å¯¹è±¡ï¼Œ
è€ŒshouldComponentUpdateå°†å§‹ç»ˆè¿”å›true

export default function finalPropsSelectorFactory(dispatch, {
  initMapStateToProps,
  initMapDispatchToProps,
  initMergeProps,
  ...options
}) {
  const mapStateToProps = initMapStateToProps(dispatch, options)
  const mapDispatchToProps = initMapDispatchToProps(dispatch, options)
  const mergeProps = initMergeProps(dispatch, options)

  if (process.env.NODE_ENV !== 'production') {
    verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps, options.displayName)
  }

  const selectorFactory = options.pure
    ? pureFinalPropsSelectorFactory
    : impureFinalPropsSelectorFactory

  return selectorFactory(
    mapStateToProps,
    mapDispatchToProps,
    mergeProps,
    dispatch,
    options
  )
}
```
selectorFactoryå‡½æ•°æ¥å—ä¸¤ä¸ªå‚æ•°ï¼Œdispatchå’ŒselectorFactoryOptions, é€šè¿‡åˆå§‹åŒ–å‡½æ•°åˆ†åˆ«ç”Ÿæˆäº†mapStateToProps mapDispatchToProps mergePropsï¼Œåœ¨éç”Ÿäº§ç¯å¢ƒä¸‹ä¼šå¯¹ä¸Šè¿°ä¸‰ä¸ªå‡½æ•°è¿›è¡ŒéªŒè¯ï¼ŒéªŒè¯ä¸‰ä¸ªå‡½æ•°æ˜¯å¦ä¸ºç©ºå’ŒmapStateToProps mapDispatchToPropså‡½æ•°ä¸­æ˜¯å¦æœ‰dependsOnOwnPropså±æ€§

å½“options.pureä¸ºfalseï¼ŒselectorFactoryçš„å€¼ä¸ºimpureFinalPropsSelectorFactory
```js
export function impureFinalPropsSelectorFactory(
  mapStateToProps,
  mapDispatchToProps,
  mergeProps,
  dispatch
) {
  return function impureFinalPropsSelector(state, ownProps) {
    return mergeProps(
      mapStateToProps(state, ownProps),
      mapDispatchToProps(dispatch, ownProps),
      ownProps
    )
  }
}
```
åœ¨é»˜è®¤æƒ…å†µä¸‹ï¼Œoptions.pureä¸ºtrueï¼Œæ­¤æ—¶selectorFactoryçš„å€¼ä¸ºpureFinalPropsSelectorFactory

å‡½æ•°pureFinalPropsSelectorFactoryæœ‰ä¸€ä¸ªå˜é‡hasRunAtLeastOnceï¼Œç”¨æ¥åˆ¤æ–­æ˜¯å¦æ˜¯ç¬¬ä¸€æ¬¡è°ƒç”¨ï¼Œå¦‚æœselectorå‡½æ•°æ˜¯ç¬¬ä¸€æ¬¡è°ƒç”¨ï¼Œselectorä¼šè¿”å›handleFirstCall(nextState, nextOwnProps)ï¼Œå¦åˆ™è¿”å›handleSubsequentCalls(nextState, nextOwnProps)

å‡½æ•°handleFirstCallä¼šåšç¼“å­˜ï¼Œä¿å­˜state ownPropsä»¥åŠmapStateToProps dispatchProps mergedPropsçš„ç»“æœ

è€Œå‡½æ•°handleSubsequentCallsä¸­ï¼ŒareOwnPropsEqual areStatesEqualåˆ†åˆ«ç”¨æ¥åˆ¤æ–­ç°åœ¨çš„propså’Œstateå€¼ä¸ç¼“å­˜çš„å€¼æ˜¯å¦ç›¸ç­‰ï¼ŒhandleSubsequentCallsé¦–å…ˆåˆ¤æ–­state propsçš„å‰åå€¼æ˜¯å¦æœ‰å˜åŒ–ï¼Œç„¶åç¼“å­˜state ownPropsï¼Œå¦‚æœpropså’Œstateéƒ½æ”¹å˜ï¼Œè¿”å›handleNewPropsAndNewStateçš„ç»“æœï¼Œå¦‚æœåªæ˜¯propsæ”¹å˜ï¼Œè¿”å›handleNewPropsçš„ç»“æœï¼Œå¦‚æœåªæ˜¯stateæ”¹å˜ï¼Œè¿”å›handleNewStateçš„ç»“æœï¼Œå¦‚æœstateå’Œpropséƒ½æ²¡æ”¹å˜ï¼Œç›´æ¥è¿”å›ä¹‹å‰ç¼“å­˜çš„mergedPropså€¼

åœ¨handleNewPropsAndNewState handleNewPropsä¸­ï¼Œä¼šæ ¹æ®mapStateToProps.dependsOnOwnPropså’ŒmapDispatchToProps.dependsOnOwnPropsåˆ¤åˆ«stateå’ŒdispatchPropsæ˜¯å¦ä¸ownPropsç›¸å…³ï¼Œä»¥åˆ¤åˆ«æ˜¯å¦éœ€è¦é‡æ–°è¿è¡ŒmapStateToPropså’ŒmapDispatchToProps

**The arity of mapStateToProps and mapDispatchToProps determines whether they receive ownProps**
å‡½æ•°mapStateToPropså’ŒmapDispatchToPropsçš„å½¢å‚æ•°é‡å†³å®šå®ƒä»¬æ˜¯å¦æ¥æ”¶ownPropsï¼Œä»è€Œå†³å®šmapStateToProps.dependsOnOwnPropså’ŒmapDispatchToProps.dependsOnOwnPropsçš„å€¼æ˜¯trueè¿˜æ˜¯false

```js
export function pureFinalPropsSelectorFactory(
  mapStateToProps,
  mapDispatchToProps,
  mergeProps,
  dispatch,
  { areStatesEqual, areOwnPropsEqual, areStatePropsEqual }
) {
  let hasRunAtLeastOnce = false
  let state
  let ownProps
  let stateProps
  let dispatchProps
  let mergedProps

  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState
    ownProps = firstOwnProps
    stateProps = mapStateToProps(state, ownProps)
    dispatchProps = mapDispatchToProps(dispatch, ownProps)
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)
    hasRunAtLeastOnce = true
    return mergedProps
  }

  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state, ownProps)

    if (mapDispatchToProps.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps(dispatch, ownProps)

    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)
    return mergedProps
  }

  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps)
      stateProps = mapStateToProps(state, ownProps)

    if (mapDispatchToProps.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps(dispatch, ownProps)

    mergedProps = mergeProps(stateProps, dispatchProps, ownProps)
    return mergedProps
  }

  function handleNewState() {
    const nextStateProps = mapStateToProps(state, ownProps)
    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps)
    stateProps = nextStateProps
    
    if (statePropsChanged)
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps)

    return mergedProps
  }

  function handleSubsequentCalls(nextState, nextOwnProps) {
    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps)
    const stateChanged = !areStatesEqual(nextState, state)
    state = nextState
    ownProps = nextOwnProps

    if (propsChanged && stateChanged) return handleNewPropsAndNewState()
    if (propsChanged) return handleNewProps()
    if (stateChanged) return handleNewState()
    return mergedProps
  }

  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce
      ? handleSubsequentCalls(nextState, nextOwnProps)
      : handleFirstCall(nextState, nextOwnProps)
  }
}
```
å¯¹connectå‡½æ•°å‚æ•°çš„è¯¦ç»†æ³¨é‡Šå¯ä»¥å‚è€ƒ[API](https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options)

```js
// connect.js
import connectAdvanced from '../components/connectAdvanced'
import shallowEqual from '../utils/shallowEqual'
import defaultMapDispatchToPropsFactories from './mapDispatchToProps'
import defaultMapStateToPropsFactories from './mapStateToProps'
import defaultMergePropsFactories from './mergeProps'
import defaultSelectorFactory from './selectorFactory'

function match(arg, factories, name) {
  for (let i = factories.length - 1; i >= 0; i--) {
    const result = factories[i](arg)
    if (result) return result
  }

  return (dispatch, options) => {
    throw new Error(`Invalid value of type ${typeof arg} for ${name} argument when connecting component ${options.wrappedComponentName}.`)
  }
}

function strictEqual(a, b) { return a === b }

// createConnect with default args builds the 'official' connect behavior. Calling it with
// different options opens up some testing and extensibility scenarios
export function createConnect({
  connectHOC = connectAdvanced,
  mapStateToPropsFactories = defaultMapStateToPropsFactories,
  mapDispatchToPropsFactories = defaultMapDispatchToPropsFactories,
  mergePropsFactories = defaultMergePropsFactories,
  selectorFactory = defaultSelectorFactory
} = {}) {
  return function connect(
    mapStateToProps,
    mapDispatchToProps,
    mergeProps,
    {
      pure = true,
      areStatesEqual = strictEqual,
      areOwnPropsEqual = shallowEqual,
      areStatePropsEqual = shallowEqual,
      areMergedPropsEqual = shallowEqual,
      ...extraOptions
    } = {}
  ) {
    const initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps')
    const initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps')
    const initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps')

    return connectHOC(selectorFactory, {
      // used in error messages
      methodName: 'connect',

       // used to compute Connect's displayName from the wrapped component's displayName.
      getDisplayName: name => `Connect(${name})`,

      // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
      shouldHandleStateChanges: Boolean(mapStateToProps),

      // passed through to selectorFactory
      initMapStateToProps,
      initMapDispatchToProps,
      initMergeProps,
      pure,
      areStatesEqual,
      areOwnPropsEqual,
      areStatePropsEqual,
      areMergedPropsEqual,

      // any extra options args can override defaults of connect or connectAdvanced
      ...extraOptions
    })
  }
}

export default createConnect()
```

## connectAdvanced.js
`connectAdvanced`æŠŠä¼ å…¥çš„Reactç»„ä»¶å’ŒRedux storeè¿›è¡Œè¿æ¥ï¼Œè¿™ä¸ªæ–¹æ³•æ˜¯connect()çš„åŸºç¡€ï¼Œä½†ç›¸æ¯”äºconnect()ç¼ºå°‘äº†åˆå¹¶state props dispatchæ–¹æ³•ï¼Œä¸åŒ…å«ä¸€äº›é…ç½®é»˜è®¤å€¼ï¼Œè¿™äº›éƒ½è¦ç”±è°ƒç”¨è€…æ¥è§£å†³

è¿™ä¸ªæ–¹æ³•ä¸ä¼šä¿®æ”¹ä¼ å…¥çš„ç»„ä»¶ï¼Œè€Œæ˜¯åœ¨å¤–é¢åŒ…è£¹ä¸€å±‚ï¼Œç”Ÿæˆä¸€ä¸ªæ–°çš„ç»„ä»¶

æ–¹æ³•ç­¾åï¼š`connectAdvanced(selectorFactory, options)(MyComponent)`

connectAdvanced  è¿”å›ä¸€ä¸ªå‡½æ•°wrapWithConnectï¼Œ å…¶æ¥å—ä¸€ä¸ªå‚æ•°WrappedComponentï¼Œåœ¨å†…éƒ¨å®šä¹‰ä¸€ä¸ªConnect Componentï¼Œ ç„¶åä½œä¸ºWrappedComponentçš„HOCè¿”å›
```js
function wrapWithConnect(WrappedComponent) {
    class Connect extends Component {
      // ...
    }
    return hoistStatics(Connect, WrappedComponent)
}
```
å…ˆæ¥çœ‹çœ‹å¼€å¤´çš„å‡½æ•°`makeSelectorStateful`ï¼Œå®ƒæ˜¯ä¸€ä¸ªutilï¼Œç”¨æ¥åŒ…è£¹selector
```js
class Connect extends Component {
  initSelector() {
    const sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions)
    this.selector = makeSelectorStateful(sourceSelector, this.store)
    this.selector.run(this.props)
  }
}

function makeSelectorStateful(sourceSelector, store) {
  const selector = {
    run: function runComponentSelector(props) {
      try {
        const nextProps = sourceSelector(store.getState(), props)
        if (nextProps !== selector.props || selector.error) {
          selector.shouldComponentUpdate = true
          selector.props = nextProps
          selector.error = null
        }
      } catch (error) {
        selector.shouldComponentUpdate = true
        selector.error = error
      }
    }
  }
  return selector
}
```
å‰é¢æˆ‘ä»¬çœ‹åˆ°ï¼Œselectorçš„ä¸»è¦ä½œç”¨æ˜¯ç”¨æ¥ä»store stateå’ŒownPropsä¸­è®¡ç®—æ–°çš„propsï¼Œå¹¶è¿”å›çº¯å¯¹è±¡(plain object)ï¼Œè¿™ä¸ªå¯¹è±¡ä¼šä½œä¸ºpropsä¼ é€’ç»™è¢«åŒ…è£¹çš„ç»„ä»¶(WrappedComponent)

åœ¨`initSelector`ä¸­ï¼Œé¦–å…ˆè°ƒç”¨selectorFactoryåˆå§‹åŒ–sourceSelectorï¼Œç„¶åé€šè¿‡å°†sourceSelectorä½œä¸ºå‚æ•°è°ƒç”¨**makeSelectorStateful**ï¼Œè¿”å›å¼ºåŒ–çš„selectorï¼Œä¹‹åæˆ‘ä»¬ç”Ÿæˆæ–°çš„propsåªéœ€è°ƒç”¨selector.runï¼Œselector.runå‡½æ•°ä¸­è¿˜æœ‰å¼‚å¸¸å¤„ç†ï¼Œå¹¶ç”¨selector.errorè®°å½•æ˜¯å¦å­˜åœ¨å¼‚å¸¸ï¼Œselector.shouldComponentUpdateæ ¹æ®å‰åä¸¤æ¬¡è¿”å›çš„propsæ˜¯å¦ç›¸åŒï¼Œå†³å®šæ˜¯å¦åº”è¯¥åˆ·æ–°ç»„ä»¶ï¼Œåªè¦å‰åpropsç›¸åŒï¼Œå°±è¿”å›åŒä¸€ä¸ªå¯¹è±¡ï¼Œä½¿å¾—shouldComponentUpdateä¸ºfalseï¼Œé¿å…ä¸å¿…è¦çš„åˆ·æ–°ï¼Œå¸¦æ¥äº†æ€§èƒ½æå‡ï¼ŒåŒæ—¶æ¯æ¬¡è¿”å›çš„æ–°çš„propséƒ½ä¼šè®°å½•åœ¨selector.propså¤‡ç”¨

```js
initSubscription() {
  if (!shouldHandleStateChanges) return
  const parentSub = (this.propsMode ? this.props : this.context)[subscriptionKey]
  this.subscription = new Subscription(this.store, parentSub, this.onStateChange.bind(this))
  this.notifyNestedSubs = this.subscription.notifyNestedSubs.bind(this.subscription)
}
```

å†æ¥çœ‹çœ‹`initSubscription`å‡½æ•°ï¼Œ`shouldHandleStateChanges = Boolean(mapStateToProps)`ï¼Œå¦‚æœæ²¡æœ‰æä¾›å‡½æ•°mapStateToPropsï¼Œåˆ™Connectç»„ä»¶ä¸ä¼šè®¢é˜…store stateçš„æ”¹å˜

å¦‚æœå½“å‰storeä¸æ˜¯ä»¥propsæ–¹å¼ä¼ å…¥ï¼Œé‚£parentSubæ˜¯this.context[subscriptionKey]ï¼Œå¦‚æœæ˜¯ä»¥propsæ–¹å¼ä¼ å…¥çš„ï¼Œ`this.propsMode = Boolean(props[storeKey])`ï¼ŒparentSubå€¼ä¸ºthis.props[storeKey]ï¼Œæ³¨æ„ï¼Œåœ¨initSubscriptionä¸­å½“å‰this.subscriptionä¸­çš„notifyNestedSubsæ–¹æ³•è¢«æ‹·è´åˆ°this.notifyNestedSubsï¼Œç›®çš„æ˜¯é˜²æ­¢åœ¨notifyå¾ªç¯è¿‡ç¨‹ä¸­ç»„ä»¶è¢«å¸è½½ï¼Œä½¿å¾—this.subscriptionä¸ºnull

æ¥ä¸‹æ¥çœ‹çœ‹Connect componentçš„ä¸»è¦ç”Ÿå‘½å‘¨æœŸå‡½æ•°
```js
componentDidMount() {
  if (!shouldHandleStateChanges) return
  this.subscription.trySubscribe()
  this.selector.run(this.props)
  if (this.selector.shouldComponentUpdate) this.forceUpdate()
}

componentWillReceiveProps(nextProps) {
  this.selector.run(nextProps)
}

shouldComponentUpdate() {
  return this.selector.shouldComponentUpdate
}

componentWillUnmount() {
  if (this.subscription) this.subscription.tryUnsubscribe()
  this.subscription = null
  this.notifyNestedSubs = noop
  this.store = null
  this.selector.run = noop
  this.selector.shouldComponentUpdate = false
}
```
Connect componentåœ¨componentDidMountæ—¶ä¼šæ ¹æ®shouldHandleStateChangesé€‰æ‹©æ˜¯å¦è®¢é˜…store stateçš„æ”¹å˜ï¼Œç»„ä»¶åœ¨componentWillReceivePropsæ¥å—propsæ—¶ï¼Œä¼šè°ƒç”¨selectorè®¡ç®—æ–°çš„propsï¼ŒshouldComponentUpdateä¼šæ ¹æ®this.selectorçš„shouldComponentUpdateæ¥åˆ¤æ–­æ˜¯å¦éœ€è¦åˆ·æ–°ç»„ä»¶ï¼Œåœ¨componentWillUnmountæ—¶ä¼šåšæ¸…ç†ï¼Œé˜²æ­¢å†…å­˜æ³„éœ²

```js
onStateChange() {
  this.selector.run(this.props)

  if (!this.selector.shouldComponentUpdate) {
    this.notifyNestedSubs()
  } else {
    this.componentDidUpdate = this.notifyNestedSubsOnComponentDidUpdate
    this.setState(dummyState)
  }
}

notifyNestedSubsOnComponentDidUpdate() {
  this.componentDidUpdate = undefined
  this.notifyNestedSubs()
}
```
onStateChangeå‡½æ•°æ˜¯store stateå˜åŒ–æ—¶çš„å›è°ƒå‡½æ•°ï¼Œå½“è°ƒç”¨onStateChangeæ—¶ï¼Œé€šè¿‡selectorè®¡ç®—æ–°çš„propsï¼Œå¦‚æœselectorçš„è®¡ç®—ç»“æœä¸­shouldComponentUpdateä¸ºfalseï¼Œè¡¨ç¤ºä¸éœ€è¦åˆ·æ–°å½“å‰ç»„ä»¶ï¼Œä»…éœ€é€šçŸ¥å­ç»„ä»¶æ›´æ–°ï¼Œå¦‚æœshouldComponentUpdateä¸ºtrueï¼Œä¼šé€šè¿‡è®¾ç½®this.setState({})æ¥åˆ·æ–°ç»„ä»¶ï¼Œå¹¶åœ¨ç»„ä»¶æ›´æ–°ç»“æŸåï¼Œé€šçŸ¥å­ç»„ä»¶æ›´æ–°

```js
getWrappedInstance() {
  return this.wrappedInstance
}

setWrappedInstance(ref) {
  this.wrappedInstance = ref
}
```
getWrappedInstanceä¸setWrappedInstanceåœ¨å‚æ•°withRefä¸ºtrueæ—¶ï¼Œè·å–æˆ–è®¾ç½®è¢«åŒ…è£¹ç»„ä»¶å®ä¾‹çš„ref


```
export default function connectAdvanced(
  selectorFactory,
  {
    getDisplayName = name => `ConnectAdvanced(${name})`,
    methodName = 'connectAdvanced',
    renderCountProp = undefined,
    shouldHandleStateChanges = true,
    storeKey = 'store',
    // if true, the wrapped element is exposed by this HOC via the getWrappedInstance() function.
    withRef = false,
    ...connectOptions
  } = {}
) {
  const subscriptionKey = storeKey + 'Subscription'
  const version = hotReloadingVersion++

  const contextTypes = {
    [storeKey]: storeShape,
    [subscriptionKey]: subscriptionShape,
  }
  const childContextTypes = {
    [subscriptionKey]: subscriptionShape,
  }

  return function wrapWithConnect(WrappedComponent) {
    invariant(
      typeof WrappedComponent == 'function',
      `You must pass a component to the function returned by ` +
      `${methodName}. Instead received ${JSON.stringify(WrappedComponent)}`
    )

    const wrappedComponentName = WrappedComponent.displayName
      || WrappedComponent.name
      || 'Component'

    const displayName = getDisplayName(wrappedComponentName)

    const selectorFactoryOptions = {
      ...connectOptions,
      getDisplayName,
      methodName,
      renderCountProp,
      shouldHandleStateChanges,
      storeKey,
      withRef,
      displayName,
      wrappedComponentName,
      WrappedComponent
    }

    class Connect extends Component {
      constructor(props, context) {
        super(props, context)

        this.version = version
        this.state = {}
        this.renderCount = 0
        this.store = props[storeKey] || context[storeKey]
        this.propsMode = Boolean(props[storeKey])
        this.setWrappedInstance = this.setWrappedInstance.bind(this)

        invariant(this.store,
          `Could not find "${storeKey}" in either the context or props of ` +
          `"${displayName}". Either wrap the root component in a <Provider>, ` +
          `or explicitly pass "${storeKey}" as a prop to "${displayName}".`
        )

        this.initSelector()
        this.initSubscription()
      }

      getChildContext() {
        const subscription = this.propsMode ? null : this.subscription
        return { [subscriptionKey]: subscription || this.context[subscriptionKey] }
      }

      componentDidMount() {
        if (!shouldHandleStateChanges) return

        this.subscription.trySubscribe()
        this.selector.run(this.props)
        if (this.selector.shouldComponentUpdate) this.forceUpdate()
      }

      componentWillReceiveProps(nextProps) {
        this.selector.run(nextProps)
      }

      shouldComponentUpdate() {
        return this.selector.shouldComponentUpdate
      }

      componentWillUnmount() {
        if (this.subscription) this.subscription.tryUnsubscribe()
        this.subscription = null
        this.notifyNestedSubs = noop
        this.store = null
        this.selector.run = noop
        this.selector.shouldComponentUpdate = false
      }

      getWrappedInstance() {
        invariant(withRef,
          `To access the wrapped instance, you need to specify ` +
          `{ withRef: true } in the options argument of the ${methodName}() call.`
        )
        return this.wrappedInstance
      }

      setWrappedInstance(ref) {
        this.wrappedInstance = ref
      }

      initSelector() {
        const sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions)
        this.selector = makeSelectorStateful(sourceSelector, this.store)
        this.selector.run(this.props)
      }

      initSubscription() {
        if (!shouldHandleStateChanges) return

        // parentSub's source should match where store came from: props vs. context. A component
        // connected to the store via props shouldn't use subscription from context, or vice versa.
        const parentSub = (this.propsMode ? this.props : this.context)[subscriptionKey]
        this.subscription = new Subscription(this.store, parentSub, this.onStateChange.bind(this))

        this.notifyNestedSubs = this.subscription.notifyNestedSubs.bind(this.subscription)
      }

      onStateChange() {
        this.selector.run(this.props)

        if (!this.selector.shouldComponentUpdate) {
          this.notifyNestedSubs()
        } else {
          this.componentDidUpdate = this.notifyNestedSubsOnComponentDidUpdate
          this.setState(dummyState)
        }
      }

      notifyNestedSubsOnComponentDidUpdate() {
        this.componentDidUpdate = undefined
        this.notifyNestedSubs()
      }

      isSubscribed() {
        return Boolean(this.subscription) && this.subscription.isSubscribed()
      }

      addExtraProps(props) {
        if (!withRef && !renderCountProp && !(this.propsMode && this.subscription)) return props
        const withExtras = { ...props }
        if (withRef) withExtras.ref = this.setWrappedInstance
        if (renderCountProp) withExtras[renderCountProp] = this.renderCount++
        if (this.propsMode && this.subscription) withExtras[subscriptionKey] = this.subscription
        return withExtras
      }

      render() {
        const selector = this.selector
        selector.shouldComponentUpdate = false

        if (selector.error) {
          throw selector.error
        } else {
          return createElement(WrappedComponent, this.addExtraProps(selector.props))
        }
      }
    }

    Connect.WrappedComponent = WrappedComponent
    Connect.displayName = displayName
    Connect.childContextTypes = childContextTypes
    Connect.contextTypes = contextTypes
    Connect.propTypes = contextTypes

    if (process.env.NODE_ENV !== 'production') {
      Connect.prototype.componentWillUpdate = function componentWillUpdate() {
        // We are hot reloading!
        if (this.version !== version) {
          this.version = version
          this.initSelector()

          let oldListeners = [];

          if (this.subscription) {
            oldListeners = this.subscription.listeners.get()
            this.subscription.tryUnsubscribe()
          }
          this.initSubscription()
          if (shouldHandleStateChanges) {
            this.subscription.trySubscribe()
            oldListeners.forEach(listener => this.subscription.listeners.subscribe(listener))
          }
        }
      }
    }

    return hoistStatics(Connect, WrappedComponent)
  }
}
```
